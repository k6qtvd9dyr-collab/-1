'INSERT OR IGNORE INTO seen_ads (monitor_id, ad_id) VALUES (?, ?)',
                    (monitor_id, ad_id)
                )
                await db.commit()
            except:
                pass

    async def is_ad_seen(self, monitor_id, ad_id):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω–æ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏—è"""
        async with aiosqlite.connect(self.db_path) as db:
            async with db.execute(
                'SELECT 1 FROM seen_ads WHERE monitor_id = ? AND ad_id = ?',
                (monitor_id, ad_id)
            ) as cursor:
                return await cursor.fetchone() is not None

class KufarParser:
    def __init__(self):
        self.headers = {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept-Language': 'ru-RU,ru;q=0.9,en;q=0.8'
        }

    async def parse_category(self, url):
        """–ü–∞—Ä—Å–∏–Ω–≥ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ Kufar"""
        try:
            async with aiohttp.ClientSession(headers=self.headers) as session:
                async with session.get(url, timeout=10) as response:
                    if response.status == 200:
                        html = await response.text()
                        return await self.parse_html(html)
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞: {e}")
        return []

    async def parse_html(self, html):
        """–ü–∞—Ä—Å–∏–Ω–≥ HTML"""
        soup = BeautifulSoup(html, 'html.parser')
        ads = []
        
        # –ü–æ–∏—Å–∫ –æ–±—ä—è–≤–ª–µ–Ω–∏–π
        for link in soup.find_all('a', href=re.compile(r'//kufar\.by/item/\d+'), limit=20):
            try:
                ad = await self.parse_ad(link)
                if ad:
                    ads.append(ad)
            except Exception as e:
                continue
        return ads

    async def parse_ad(self, link):
        """–ü–∞—Ä—Å–∏–Ω–≥ –æ–±—ä—è–≤–ª–µ–Ω–∏—è"""
        try:
            href = link.get('href', '')
            if not href.startswith('http'):
                href = 'https:' + href
            
            ad_id = re.search(r'/item/(\d+)', href)
            if not ad_id:
                return None
            
            title_elem = link.find(['h3', 'div'], class_=re.compile(r'title|subject'))
            price_elem = link.find(['p', 'span'], class_=re.compile(r'price'))
            location_elem = link.find(['span', 'div'], class_=re.compile(r'location|region'))
            img_elem = link.find('img')
            
            return {
                'id': ad_id.group(1),
                'title': title_elem.get_text(strip=True) if title_elem else '–ë–µ–∑ –Ω–∞–∑–≤–∞–Ω–∏—è',
                'price': price_elem.get_text(strip=True) if price_elem else '–¶–µ–Ω–∞ –Ω–µ —É–∫–∞–∑–∞–Ω–∞',
                'url': href,
                'location': location_elem.get_text(strip=True) if location_elem else '–ù–µ —É–∫–∞–∑–∞–Ω–æ',
                'image_url': img_elem.get('src') if img_elem else None
            }
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –æ–±—ä—è–≤–ª–µ–Ω–∏—è: {e}")
            return None

class KufarBot:
    def __init__(self, token):
        self.token = token
        self.monitor = KufarMonitor()
        self.parser = KufarParser()
        self.user_states = {}

    async def start(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ö–æ–º–∞–Ω–¥–∞ /start"""
        user = update.effective_user
        await self.monitor.add_user(user.id, user.username)
        
        text = """
üè† <b>Kufar Monitor Pro</b>

‚ö° <b>–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –Ω–æ–≤—ã—Ö –æ–±—ä—è–≤–ª–µ–Ω–∏–π –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É!</b>

üìã <b>–ö–æ–º–∞–Ω–¥—ã:</b>
/start - –ì–ª–∞–≤–Ω–æ–µ –º–µ–Ω—é
/add - –î–æ–±–∞–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä  
/list - –ú–æ–∏ –º–æ–Ω–∏—Ç–æ—Ä—ã
/help - –ü–æ–º–æ—â—å

üéØ <b>–ë—ã—Å—Ç—Ä—ã–π —Å—Ç–∞—Ä—Ç:</b>
1. –ù–∞–∂–º–∏—Ç–µ "‚ûï –î–æ–±–∞–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä"
2. –£–∫–∞–∂–∏—Ç–µ URL –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ Kufar
3. –ù–∞—Å—Ç—Ä–æ–π—Ç–µ —Ñ–∏–ª—å—Ç—Ä—ã
4. –ü–æ–ª—É—á–∞–π—Ç–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è!
        """
        
        keyboard = [
            [InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä", callback_data="add_monitor")],
            [InlineKeyboardButton("üìã –ú–æ–∏ –º–æ–Ω–∏—Ç–æ—Ä—ã", callback_data="list_monitors")],
        ]
        await update.message.reply_html(text, reply_markup=InlineKeyboardMarkup(keyboard))

import os
import asyncio
import logging
import aiosqlite
import aiohttp
from bs4 import BeautifulSoup
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes, MessageHandler, filters
from datetime import datetime
import re

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

class KufarMonitor:
    def __init__(self, db_path='kufar.db'):
        self.db_path = db_path
        self.init_db()

    async def init_db(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                CREATE TABLE IF NOT EXISTS users (
                    user_id INTEGER PRIMARY KEY,
                    username TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            
            await db.execute('''
                CREATE TABLE IF NOT EXISTS monitors (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    user_id INTEGER,
                    name TEXT NOT NULL,
                    url TEXT NOT NULL,
                    keywords TEXT,
                    min_price INTEGER,
                    max_price INTEGER,
                    is_active BOOLEAN DEFAULT 1,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    FOREIGN KEY (user_id) REFERENCES users (user_id)
                )
            ''')
            
            await db.execute('''
                CREATE TABLE IF NOT EXISTS seen_ads (
                    monitor_id INTEGER,
                    ad_id TEXT,
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    PRIMARY KEY (monitor_id, ad_id)
                )
            ''')
            await db.commit()

    async def add_user(self, user_id, username):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute(
                'INSERT OR IGNORE INTO users (user_id, username) VALUES (?, ?)',
                (user_id, username)
            )
            await db.commit()

    async def add_monitor(self, user_id, name, url, keywords=None, min_price=None, max_price=None):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∞"""
        async with aiosqlite.connect(self.db_path) as db:
            cursor = await db.execute('''
                INSERT INTO monitors (user_id, name, url, keywords, min_price, max_price)
                VALUES (?, ?, ?, ?, ?, ?)
            ''', (user_id, name, url, keywords, min_price, max_price))
            await db.commit()
            return cursor.lastrowid

    async def get_user_monitors(self, user_id):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        async with aiosqlite.connect(self.db_path) as db:
            async with db.execute('''
                SELECT * FROM monitors WHERE user_id = ? ORDER BY created_at DESC
            ''', (user_id,)) as cursor:
                return await cursor.fetchall()

    async def toggle_monitor(self, monitor_id, user_id):
        """–í–∫–ª—é—á–µ–Ω–∏–µ/–≤—ã–∫–ª—é—á–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∞"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('''
                UPDATE monitors SET is_active = NOT is_active 
                WHERE id = ? AND user_id = ?
            ''', (monitor_id, user_id))
            await db.commit()

    async def delete_monitor(self, monitor_id, user_id):
        """–£–¥–∞–ª–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∞"""
        async with aiosqlite.connect(self.db_path) as db:
            await db.execute('DELETE FROM monitors WHERE id = ? AND user_id = ?', (monitor_id, user_id))
            await db.commit()

    async def add_seen_ad(self, monitor_id, ad_id):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –ø—Ä–æ—Å–º–æ—Ç—Ä–µ–Ω–Ω–æ–≥–æ –æ–±—ä—è–≤–ª–µ–Ω–∏—è"""
        async with aiosqlite.connect(self.db_path) as db:
            try:
                await db.execute(
async def handle_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏–π"""
        user_id = update.effective_user.id
        text = update.message.text
        
        if user_id in self.user_states:
            state = self.user_states[user_id]
            if state['action'] == 'waiting_url':
                await self.process_url(update, context, text)
            elif state['action'] == 'waiting_name':
                await self.process_name(update, context, text)
            elif state['action'] == 'waiting_keywords':
                await self.process_keywords(update, context, text)

    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫"""
        query = update.callback_query
        await query.answer()
        
        data = query.data
        user_id = query.from_user.id
        
        if data == "add_monitor":
            await self.start_add_monitor(query)
        elif data == "list_monitors":
            await self.show_monitors(query)
        elif data.startswith("toggle_"):
            monitor_id = int(data.split("_")[1])
            await self.toggle_monitor(query, monitor_id)
        elif data.startswith("delete_"):
            monitor_id = int(data.split("_")[1])
            await self.delete_monitor(query, monitor_id)

    async def start_add_monitor(self, query):
        """–ù–∞—á–∞–ª–æ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è –º–æ–Ω–∏—Ç–æ—Ä–∞"""
        self.user_states[query.from_user.id] = {'action': 'waiting_url'}
        await query.edit_message_text(
            "üîó <b>–®–∞–≥ 1 –∏–∑ 3</b>\n–û—Ç–ø—Ä–∞–≤—å—Ç–µ URL –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ Kufar:\n\n"
            "<i>–ü—Ä–∏–º–µ—Ä: https://kufar.by/l/elektronika</i>",
            parse_mode='HTML'
        )

    async def process_url(self, update, context, url):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ URL"""
        user_id = update.effective_user.id
        
        if not url.startswith('https://kufar.by/'):
            await update.message.reply_text("‚ùå –ù–µ–≤–µ—Ä–Ω—ã–π URL. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –µ—â–µ —Ä–∞–∑:")
            return
        
        # –ü—Ä–æ–≤–µ—Ä—è–µ–º URL
        test_ads = await self.parser.parse_category(url)
        if not test_ads:
            await update.message.reply_text("‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ–±—ä—è–≤–ª–µ–Ω–∏—è. –ü—Ä–æ–≤–µ—Ä—å—Ç–µ URL:")
            return
        
        self.user_states[user_id] = {
            'action': 'waiting_name',
            'url': url
        }
        await update.message.reply_text(
            f"‚úÖ –ù–∞–π–¥–µ–Ω–æ –æ–±—ä—è–≤–ª–µ–Ω–∏–π: {len(test_ads)}\n\n"
            "üìù <b>–®–∞–≥ 2 –∏–∑ 3</b>\n–ü—Ä–∏–¥—É–º–∞–π—Ç–µ –Ω–∞–∑–≤–∞–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∞:",
            parse_mode='HTML'
        )

    async def process_name(self, update, context, name):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –Ω–∞–∑–≤–∞–Ω–∏—è"""
        user_id = update.effective_user.id
        state = self.user_states[user_id]
        
        self.user_states[user_id] = {
            'action': 'waiting_keywords', 
            'url': state['url'],
            'name': name
        }
        
        await update.message.reply_text(
            "üîç <b>–®–∞–≥ 3 –∏–∑ 3</b>\n–£–∫–∞–∂–∏—Ç–µ –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ (—á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é):\n\n"
            "<i>–ü—Ä–∏–º–µ—Ä: iphone, apple, –∞–π—Ñ–æ–Ω\n–ò–ª–∏ –æ—Ç–ø—Ä–∞–≤—å—Ç–µ '-' –±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–æ–≤</i>",
            parse_mode='HTML'
        )

    async def process_keywords(self, update, context, keywords):
        """–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ –¥–æ–±–∞–≤–ª–µ–Ω–∏—è"""
        user_id = update.effective_user.id
        state = self.user_states[user_id]
        
        monitor_id = await self.monitor.add_monitor(
            user_id, state['name'], state['url'], 
            keywords if keywords != '-' else None
        )
        
        # –£–¥–∞–ª—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ
        del self.user_states[user_id]
        
        await update.message.reply_text(
            f"‚úÖ <b>–ú–æ–Ω–∏—Ç–æ—Ä —Å–æ–∑–¥–∞–Ω!</b>\n\n"
            f"üìÅ {state['name']}\n"
            f"üîó {state['url'][:50]}...\n"
            f"üîç –§–∏–ª—å—Ç—Ä—ã: {keywords if keywords != '-' else '–Ω–µ—Ç'}\n\n"
            f"‚ö°Ô∏è <b>–ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥ –∑–∞–ø—É—â–µ–Ω!</b>",
            parse_mode='HTML'
        )

    async def show_monitors(self, query):
        """–ü–æ–∫–∞–∑–∞—Ç—å –º–æ–Ω–∏—Ç–æ—Ä—ã"""
        user_id = query.from_user.id
        monitors = await self.monitor.
get_user_monitors(user_id)
        
        if not monitors:
            await query.edit_message_text("üì≠ –£ –≤–∞—Å –Ω–µ—Ç –º–æ–Ω–∏—Ç–æ—Ä–æ–≤.")
            return
        
        text = "üìã <b>–í–∞—à–∏ –º–æ–Ω–∏—Ç–æ—Ä—ã:</b>\n\n"
        keyboard = []
        
        for monitor in monitors:
            id, _, name, url, keywords, min_price, max_price, is_active, created = monitor
            status = "üü¢" if is_active else "üî¥"
            text += f"{status} <b>{name}</b>\n{url[:50]}...\n\n"
            
            keyboard.append([
                InlineKeyboardButton(f"{'üî¥ –í—ã–∫–ª' if is_active else 'üü¢ –í–∫–ª'} {name}", 
                                   callback_data=f"toggle_{id}"),
                InlineKeyboardButton("üóëÔ∏è", callback_data=f"delete_{id}")
            ])
        
        keyboard.append([InlineKeyboardButton("‚ûï –î–æ–±–∞–≤–∏—Ç—å", callback_data="add_monitor")])
        await query.edit_message_text(text, parse_mode='HTML', 
                                    reply_markup=InlineKeyboardMarkup(keyboard))

    async def toggle_monitor(self, query, monitor_id):
        """–ü–µ—Ä–µ–∫–ª—é—á–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∞"""
        user_id = query.from_user.id
        await self.monitor.toggle_monitor(monitor_id, user_id)
        await query.answer("‚úÖ –°—Ç–∞—Ç—É—Å –∏–∑–º–µ–Ω–µ–Ω")
        await self.show_monitors(query)

    async def delete_monitor(self, query, monitor_id):
        """–£–¥–∞–ª–µ–Ω–∏–µ –º–æ–Ω–∏—Ç–æ—Ä–∞"""
        user_id = query.from_user.id
        await self.monitor.delete_monitor(monitor_id, user_id)
        await query.answer("üóëÔ∏è –ú–æ–Ω–∏—Ç–æ—Ä —É–¥–∞–ª–µ–Ω")
        await self.show_monitors(query)

    async def check_monitors(self, context: ContextTypes.DEFAULT_TYPE):
        """–ü—Ä–æ–≤–µ—Ä–∫–∞ –º–æ–Ω–∏—Ç–æ—Ä–æ–≤ –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É"""
        logger.info("‚ö°Ô∏è –ú–∏–Ω—É—Ç–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞...")
        
        # –ó–¥–µ—Å—å –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ª–æ–≥–∏–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ –≤—Å–µ—Ö –∞–∫—Ç–∏–≤–Ω—ã—Ö –º–æ–Ω–∏—Ç–æ—Ä–æ–≤
        # –î–ª—è –ø—Ä–æ—Å—Ç–æ—Ç—ã –ø—Ä–æ–ø—É—Å—Ç–∏–º –ø–æ–ª–Ω—É—é —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—é

    def run(self):
        """–ó–∞–ø—É—Å–∫ –±–æ—Ç–∞"""
        application = Application.builder().token(self.token).build()
        
        # –û–±—Ä–∞–±–æ—Ç—á–∏–∫–∏
        application.add_handler(CommandHandler("start", self.start))
        application.add_handler(CommandHandler("list", self.show_monitors))
        application.add_handler(CommandHandler("add", self.start_add_monitor))
        application.add_handler(CallbackQueryHandler(self.button_handler))
        application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, self.handle_message))
        
        # –ú–∏–Ω—É—Ç–Ω–∞—è –ø—Ä–æ–≤–µ—Ä–∫–∞
        application.job_queue.run_repeating(self.check_monitors, interval=60, first=10)
        
        print("üöÄ –ë–æ—Ç –∑–∞–ø—É—â–µ–Ω! (–ø—Ä–æ–≤–µ—Ä–∫–∞ –∫–∞–∂–¥—É—é –º–∏–Ω—É—Ç—É)")
        application.run_polling()

if name == "__main__":
    token = os.environ.get('BOT_TOKEN')
    if not token:
        print("‚ùå BOT_TOKEN –Ω–µ –Ω–∞–π–¥–µ–Ω!")
    else:
        KufarBot(token).run()
